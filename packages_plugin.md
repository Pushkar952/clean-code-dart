![alt text](https://storage.googleapis.com/cms-storage-bucket/70760bf1e88b184bb1bc.png)

## **Plugin**

> A plugin is a piece of software that adds capabilities to your app. For example, you might want your mobile app to interact with the camera on your device. Plugins are an important part of the Flutter ecosystem</br>Flutter makes it easy for users to interact with cross-platform Dart libraries, but sometimes it's ideal to interact with platform-specific code. For example, you might want to communicate with a database that doesn't have a Dart library written for it. Flutter provides a mechanism for authoring plugins that allows you to communicate with platform-specific code and also allows you to publish your plugins on pub.dev so that others can use them.

**Steps to generate plugin**

> Flutter ships with templates for plugins that make it easy to get started. When you generate the plugin template, you can specify which language you want to use. The default is Swift for iOS and Kotlin for Android. For this codelab, you use Objective-C and Java.

Example =>

```
flutter create --template=plugin --org com.example --platforms=android,ios -a java -i objc plugin_codelab
```

Some important files that are generated by running the above command

- pubspec.yaml—The YAML file that defines your plugin. It specifies the plugin's name, dependencies, version, supported operating systems, and so on. This is used on your plugin's pub.dev page
- CHANGELOG.md—Any time that you want to publish a new version of a plugin you must update this markdown file to indicate the changes in the new version
- README.md—This markdown file shows up on the front page of the plugin's pub.dev listing. It should describe, in detail, what the plugin is and how to use it.
- lib/plugin_codelab.dart—The Dart code that implements the frontend to your plugin. Plugin clients have access to the public classes and functions in this directory.
- android/src/main/java/com/example/plugin_codelab/PluginCodelabPlugin.java—The native Java code that implements the Android feature described in plugin_codelab.dart.
- ios/Classes/PluginCodelabPlugin.m—The Objective-C code that implements the iOS feature described in plugin_codelab.dart. (There is a matching header file as well.)
- example/—This directory contains a client of your plugin. While developing your plugin, you edit this file to see your plugin in action.
- example/lib/main.dart—The Dart code that exercises your plugin. You build the example UI here.

**Now if you see the file under project_name -> lib, you will find the default code as**

```
import 'dart:async';
import 'package:flutter/services.dart';
class FlutterAlertDemo {
static const MethodChannel _channel =
const MethodChannel('flutter_alert_demo');
static Future<String> get platformVersion async {
final String version = await _channel.invokeMethod ('getPlatformVersion');
return version;
    }
}
```

> So we have a property that platformVersion which is asking \_channel to invoke one method which is getting platform version which is defined in Android as well as in iOS and from (‘getPlatformVersion) we are getting the version and we are returning this version to our flutter project.

**Android Native code(java code):**

> You will find this code in the Android section (project_name -> android)

```
package adhoc.successive.com.flutteralertdemo;
import android.app.Activity;
import android.app.Dialog;
import io.flutter.plugin.common.MethodCall;
import io.flutter.plugin.common.MethodChannel;
import io.flutter.plugin.common.MethodChannel.MethodCallHandler;
import io.flutter.plugin.common.MethodChannel.Result;
import io.flutter.plugin.common.PluginRegistry.Registrar;
/** FlutterAlertDemoPlugin */
public class FlutterAlertDemoPlugin implements MethodCallHandler {
    /** Plugin registration. */
public static void registerWith(Registrar registrar) {
        final MethodChannel channel = new MethodChannel(registrar.messenger(), "flutter_alert_demo");
        channel.setMethodCallHandler(new FlutterAlertDemoPlugin());
    }
    @Override
    public void onMethodCall(MethodCall call, Result result) {
        if (call.method.equals("getPlatformVersion")) {
            if (call.method == "getPlatformVersion") {
           result("iOS " + UIDevice.current.systemVersion)
       }
            result.success("Android " + android.os.Build.VERSION.RELEASE);
        } else {
            result.notImplemented();
        }
    }
}
```

**iOS Native code(swift code):**

> You will find this code in the Android section (project_name -> ios)

```
import Flutter
import UIKit
public class SwiftFlutterAlertDemoPlugin: NSObject, FlutterPlugin {
 public static func register(with registrar: FlutterPluginRegistrar) {
   let channel = FlutterMethodChannel(name: "flutter_alert_demo", binaryMessenger: registrar.messenger())
   let instance = SwiftFlutterAlertDemoPlugin()
   registrar.addMethodCallDelegate(instance, channel: channel)
 }
public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
    result("iOS " + UIDevice.current.systemVersion)
 }
}
```

By overriding `onMethodCall()` in Android and implementing `handle()` in IOS, we can write custom operation.<br>
Here in the above example, When we try to invoke method `getPlatformVersion()` from dart code, then in Android and IOS, it will get checked first that, if the requested method is handled or not.

> Note: channelName will be checked first

**_Android =>_**

```
 if (call.method.equals("getPlatformVersion"))
```

**_IOS_**

```
 if (call.method == "getPlatformVersion")
```

> With response to the above conditions, the natively written operation will get performed.

## **Publish Plugin**

These are the following command to publish plugin into https://pub.dartlang.org/

```
flutter packages pub publish--dry-run
flutter packages pub publish
```

## **Package**

> Packages enable the creation of modular code that can be shared easily. A minimal package consists of the following:

- pubspec.yaml
  A metadata file that declares the package name, version, author, and so on.
  lib
- The lib directory contains the public code in the package, minimally a single `package-name.dart` file.

### **Types of Flutter packages**

- **Dart packages**

> General packages written in Dart, for example the path package. Some of these might contain Flutter specific functionality and thus have a dependency on the Flutter framework, restricting their use to Flutter only.

- **Plugin packages**

> A specialized Dart package that contains an API written in Dart code combined with one or more platform-specific implementations.
> Plugin packages can be written for Android (using Kotlin or Java), iOS (using Swift or Objective-C), web, macOS, Windows, or Linux, or any combination thereof.

## **Command to create a package**

```
flutter create --template=package hello

```

> For pure Dart packages, simply add the functionality inside the main `lib/package name.dart` file, or in several files in the lib directory

For plugin package you can visit the below link.

[Developing plugin packages](https://docs.flutter.dev/development/packages-and-plugins/developing-packages#plugin)
